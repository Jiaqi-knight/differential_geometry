# Autogenerated with SMOP 
from smop.core import *
# 

    
@function
def computecovariantbase3Dsurface(N=None,deltaq=None,lattice=None,firstdevneighbours=None,*args,**kwargs):
    varargin = computecovariantbase3Dsurface.varargin
    nargin = computecovariantbase3Dsurface.nargin

    ##
#        Project: Fluid - structure interaction on deformable surfaces
#         Author: Luca Di Stasio
#    Institution: ETH Zrich
#                 Institute for Building Materials
# Research group: Computational Physics for Engineering Materials
#        Version: 0.1
#  Creation date: July 17th, 2014
#    Last update: July 17th, 2014
    
    #    Description: 
#          Input: 
#         Output:
    
    ##
    
    covariantbase=zeros(N,9)
    for i in arange(1,N).reshape(-1):
        for j in arange(1,2).reshape(-1):
            if 1 == firstdevneighbours[i,dot(4,(j - 1)) + 1]:
                covariantbase[i,dot(3,(j - 1)) + 1:dot(3,(j - 1)) + 3]=multiply(0.5,cat((lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],7] - lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],7]),(lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],8] - lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],8]),(lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],9] - lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],9]))) / deltaq[j]
            else:
                if 2 == firstdevneighbours[i,dot(4,(j - 1)) + 1]:
                    covariantbase[i,dot(3,(j - 1)) + 1:dot(3,(j - 1)) + 3]=cat((dot(- 1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],7]) + dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],7]) - dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],7])),(dot(- 1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],8]) + dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],8]) - dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],8])),(dot(- 1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],9]) + dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],9]) - dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],9]))) / deltaq[j]
                else:
                    if 3 == firstdevneighbours[i,dot(4,(j - 1)) + 1]:
                        covariantbase[i,dot(3,(j - 1)) + 1:dot(3,(j - 1)) + 3]=cat((dot(1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],7]) - dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],7]) + dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],7])),(dot(- 1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],8]) + dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],8]) - dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],8])),(dot(- 1.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 2],9]) + dot(2,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 3],9]) - dot(0.5,lattice[firstdevneighbours[i,dot(4,(j - 1)) + 4],9]))) / deltaq[j]
        vecprod=matlabarray(cat((dot(covariantbase[i,2],covariantbase[i,6]) - dot(covariantbase[i,3],covariantbase[i,5])),(dot(covariantbase[i,3],covariantbase[i,4]) - dot(covariantbase[i,1],covariantbase[i,6])),(dot(covariantbase[i,1],covariantbase[i,5]) - dot(covariantbase[i,2],covariantbase[i,4]))))
        norm=sqrt(sum(vecprod ** 2,2))
        covariantbase[i,7:9]=vecprod / norm
    
    return covariantbase